#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2014 EPFL.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.


"""Process the raw experimental data into tables and graphs."""

__author__ = "stefan.bucur@epfl.ch (Stefan Bucur)"


import argparse
import ast
import bisect
import fnmatch
import json
import numpy as np
import os
import subprocess

import prettytable
import yaml

from chef import light


class SourceFilter(object):
    """A filter for covered statements."""

    def __init__(self, filter_strings):
        self.filters = [self._parseFilterString(fs) for fs in filter_strings]

    def _parseFilterString(self, filter_string):
        tokens = filter_string.rsplit(":", 1)
        file_pattern = tokens[0]
        intervals = []
        if len(tokens) > 1 and tokens[1]:
            tokens = tokens[1].split(",")
            for token in tokens:
                if not token:
                    continue
                left, right = token.split("-")
                intervals.append((int(left) if left else None,
                                  int(right) if right else None))
        return file_pattern, intervals

    def _filter(self, filter, file_name, statements):
        if not fnmatch.fnmatch(file_name, filter[0]):
            return []

        if not filter[1]:
            return list(statements)

        result = []
        for statement in statements:
            for left, right in filter[1]:
                if ((not left or statement >= left) and
                    (not right or statement <= right)):
                    result.append(statement)
                    break
        return result

    def filter(self, file_name, statements):
        result = set()
        for filter in self.filters:
            result |= set(self._filter(filter, file_name, statements))
        return sorted(result)


class TestCollection(object):
    """A collection of test cases generated by Chef."""

    def __init__(self, file_name):
        self._file_name = file_name
        self._test_cases = None
        self._stamps = None

    def _load_test_cases(self):
        with open(self._file_name, "r") as f:
            self._test_cases = light.SymbolicTestCase.loadFromFile(f)
        self._test_cases.sort(key=lambda test_case: test_case.timestamp)
        self._stamps = [tc.timestamp for tc in self._test_cases]

    @property
    def test_cases(self):
        if self._test_cases:
            return self._test_cases
        self._load_test_cases()
        return self._test_cases

    @property
    def stamps(self):
        if self._stamps:
            return self._stamps
        self._load_test_cases()
        return self._stamps

    def countSince(self, timestamp):
        return bisect.bisect(self.stamps, timestamp)

    def __len__(self):
        if self._test_cases:
            return len(self._test_cases)
        count_line = subprocess.check_output(["wc", "-l", self._file_name])
        return int(count_line.split()[0])


class KLEERunStats(object):
    """KLEE execution statistics."""

    def __init__(self, run_stats_file):
        self.stat_header = None
        self.stat_lines = []

        for line in run_stats_file:
            if not self.stat_header:
                self.stat_header = ast.literal_eval(line)
            else:
                self.stat_lines.append(ast.literal_eval(line))


class Experiment(object):
    """Facilitates access to the information contained in a Chef experiment directory."""

    COVERAGE_FILE = "coverage.json"

    CFG_TESTS_FILE = "cfg_test_cases.dat"
    HL_TESTS_FILE = "hl_test_cases.dat"
    LL_TESTS_FILE = "all_test_cases.dat"

    ENCODING = "utf-8"

    def __init__(self, exp_dir):
        self.exp_dir = exp_dir

        self._coverage_data = None
        self._run_stats = None

        self.high_level_tests = TestCollection(os.path.join(self.exp_dir, self.HL_TESTS_FILE))
        self.low_level_tests = TestCollection(os.path.join(self.exp_dir, self.LL_TESTS_FILE))

    def __str__(self):
        return self.exp_dir

    def __repr__(self):
        return "Experiment(%s)" % self.exp_dir

    @property
    def coverage_data(self):
        if self._coverage_data:
            return self._coverage_data
        with open(os.path.join(self.exp_dir, self.COVERAGE_FILE), "r") as f:
            self._coverage_data = json.load(f, encoding=self.ENCODING)
        return self._coverage_data

    @property
    def run_stats(self):
        if self._run_stats:
            return self._run_stats
        with open(os.path.join(self.exp_dir, "run.stats"), "r") as f:
            self._run_stats = KLEERunStats(f)
        return self._run_stats

    def countTotalStatements(self, src_filter):
        return sum([len(src_filter.filter(file_name, self.coverage_data[file_name]["executable"]))
                    for file_name in self.coverage_data])

    def countMissingStatements(self, src_filter):
        return sum([len(src_filter.filter(file_name, self.coverage_data[file_name]["missing"]))
                    for file_name in self.coverage_data])

    def countCoveredStatements(self, src_filter):
        return self.countTotalStatements(src_filter) - self.countMissingStatements(src_filter)

    def total_time(self):
        wall_time_index = self.run_stats.stat_header.index("WallTime")
        return self.run_stats.stat_lines[-1][wall_time_index]


class NICETiming(object):
    def __init__(self, timing_file_name):
        self.timing_info = {}
        with open(timing_file_name, "r") as f:
            for line in f:
                frame_count, path_count, time = line.split()
                frame_count, path_count = int(frame_count), int(path_count)
                time = float(time)
                self.timing_info[frame_count] = (path_count, time)

    def get_path_count(self, frame_count):
        return self.timing_info.get(frame_count, (None, None))[0]

    def get_time(self, frame_count):
        return self.timing_info.get(frame_count, (None, None))[1]


class GnuplotError(Exception):
    pass


class GnuplotScript(object):
    GNUPLOT_COMMAND = "gnuplot"

    DEFAULT_TERMINAL = 'postscript eps enhanced'
    DEFAULT_WIDTH = "3.2 in"
    DEFAULT_HEIGHT = "1.6 in"
    DEFAULT_FONT_SIZE = 12

    TERMINAL_TEMPLATE = """set terminal %(terminal)s %(fontsize)d size %(width)s, %(height)s"""
    OUTPUT_TEMPLATE = """set output "%(output)s" """

    PLOT_TEMPLATE = """
    %(header)s
    %(output)s
    %(body)s
    """

    def __init__(self, script):
        self.script = script

    def plot(self, output_file, terminal=None, font_size=None, width=None, height=None, **params):
        terminal = terminal or self.DEFAULT_TERMINAL
        font_size = font_size or self.DEFAULT_FONT_SIZE
        width = width or self.DEFAULT_WIDTH
        height = height or self.DEFAULT_HEIGHT

        plot = self.PLOT_TEMPLATE % {
            "header": self.TERMINAL_TEMPLATE % {
                "terminal": terminal,
                "fontsize": font_size,
                "width": width,
                "height": height
            },
            "output": self.OUTPUT_TEMPLATE % {"output": output_file},
            "body": self.script % params
        }

        process = subprocess.Popen(self.GNUPLOT_COMMAND, stdin=subprocess.PIPE,
                                   stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        _, stderr_data = process.communicate(plot)
        if process.returncode != 0:
            raise GnuplotError(stderr_data)


class Analysis(object):
    EXPERIMENT_ROOT = os.path.join(os.path.dirname(__file__), "expdata")
    PLOTS_ROOT = os.path.join(os.path.dirname(__file__), "plots")
    DATA_ROOT = os.path.join(PLOTS_ROOT, "data")

    def __init__(self, exp_config):
        self.exp_config = exp_config

    def compute_data(self):
        pass

    def plot_graphs(self):
        pass


class NICEComparison(Analysis):
    def __init__(self, exp_config):
        super(NICEComparison, self).__init__(exp_config)
        self.data_file = os.path.join(self.DATA_ROOT, "nice-comparison.txt")
        self.plot_file = os.path.join(self.PLOTS_ROOT, "nice-comparison.eps")

    def compute_data(self):
        nice_data = self.exp_config["nicecompare"]

        table = prettytable.PrettyTable(["FrameCount", "CHEFPaths", "SEGTime", "NICEPaths", "NICETime"])
        table.set_style(prettytable.PLAIN_COLUMNS)

        nice_timing = NICETiming(os.path.join(os.path.dirname(__file__),
                                              nice_data["nice"]["timingfile"]))

        for frame_count in range(nice_data["min-frames"], nice_data["max-frames"]+1):
            chef_exp_dir = os.path.join(self.EXPERIMENT_ROOT,
                                        nice_data["chef"]["expdir"],
                                        nice_data["chef"]["config"],
                                        nice_data["chef"]["jobname"] % frame_count)

            chef_experiment = Experiment(chef_exp_dir)

            table.add_row([frame_count,
                           len(chef_experiment.high_level_tests),
                           chef_experiment.total_time(),
                           nice_timing.get_path_count(frame_count),
                           nice_timing.get_time(frame_count)])

        with open(self.data_file, "w") as f:
            print >>f, table

    def plot_graphs(self):
        plot = GnuplotScript(r"""
        set xlabel "Size of Symbolic Input [# of frames]"
        set xrange [1:10]

        set ylabel "CHEF Overhead\n(T_{CHEF}/T_{NICE})"

        set grid xtics ytics

        plot "%(datafile)s" every ::1 using 1:(($3/$2)/($5/$4)) with linespoints pt 2 ps 0.8 notitle
        """)

        plot.plot(self.plot_file, datafile=self.data_file)


class NICEOptimizationImpact(Analysis):
    def __init__(self, exp_config):
        super(NICEOptimizationImpact, self).__init__(exp_config)
        self.data_file = os.path.join(self.DATA_ROOT, "nice-optimizations.txt")
        self.plot_file = os.path.join(self.PLOTS_ROOT, "nice-optimizations.eps")

    def compute_data(self):
        nice_data = self.exp_config["nicecompare"]

        table = prettytable.PrettyTable(["FrameCount", "NICE"] +
                                        ['"%s"' % opt["label-full"] for opt in nice_data["chef"]["opt"]])
        table.set_style(prettytable.PLAIN_COLUMNS)

        nice_timing = NICETiming(os.path.join(os.path.dirname(__file__),
                                              nice_data["nice"]["timingfile"]))

        for frame_count in range(nice_data["min-frames"], nice_data["max-frames"]+1):
            data_row = [frame_count,
                        float(nice_timing.get_time(frame_count))/nice_timing.get_path_count(frame_count)]
            for optimization in nice_data["chef"]["opt"]:
                experiment = Experiment(os.path.join(self.EXPERIMENT_ROOT,
                                                     optimization["expdir"],
                                                     nice_data["chef"]["config"],
                                                     nice_data["chef"]["jobname"] % frame_count))
                data_row.append(float(experiment.total_time())/len(experiment.high_level_tests))
            table.add_row(data_row)

        with open(self.data_file, "w") as f:
            print >>f, table

    def plot_graphs(self):
        plot = GnuplotScript(r"""
        set xlabel "Size of Symbolic Input [# of frames]"
        set xrange [1:10]

        set ylabel "CHEF Overhead T_{CHEF}/T_{NICE}"
        set logscale y
        set yrange [*:100000]

        set grid xtics ytics

        plot for [i=0:3] "%(datafile)s" using 1:(column(i+3)/$2) with linespoints lt (i < 3 ? 3 : 1) \
                                                                                  pt (i < 3 ? (4 + i * 2) : 5) \
                                                                                  ps (i < 3 ? 0.8 : 1.0) \
                                                                                  title columnhead(i+3)
        """)
        plot.plot(self.plot_file, datafile=self.data_file)


class BreakdownPathEffectiveness(Analysis):
    def __init__(self, exp_config, language):
        super(BreakdownPathEffectiveness, self).__init__(exp_config)
        self.language = language
        self.data_file = os.path.join(self.DATA_ROOT, "bkdown-path-%s.txt" % self.language)
        self.plot_file = os.path.join(self.PLOTS_ROOT, "bkdown-path-%s.eps" % self.language)

    def compute_data(self):
        breakdown_data = self.exp_config["breakdown"]

        header = ["Package"]
        for config in breakdown_data["config"]:
            header.append('"%s"' % config["label"])
            header.append('"%s Stdev"' % config["label"])
            header.append('"%s Rel"' % config["label"])
            header.append('"%s Rel Stdev"' % config["label"])
        table = prettytable.PrettyTable(header)
        table.set_style(prettytable.PLAIN_COLUMNS)

        for job in breakdown_data[self.language]["jobs"]:
            job_row = [job["name"]]
            reference_config = breakdown_data["config"][-1]
            reference_exp = [Experiment(os.path.join(self.EXPERIMENT_ROOT, exp_dir,
                                                     reference_config["strat-path"],
                                                     job["name"]))
                             for exp_dir in breakdown_data[self.language]["expdir"][reference_config["expdir"]]]
            reference_data = np.array([len(exp.high_level_tests) for exp in reference_exp], dtype=float)
            for config in breakdown_data["config"]:
                experiments = [Experiment(os.path.join(self.EXPERIMENT_ROOT, exp_dir,
                                                       config["strat-path"],
                                                       job["name"]))
                               for exp_dir in breakdown_data[self.language]["expdir"][config["expdir"]]]
                config_data = np.array([len(exp.high_level_tests) for exp in experiments], dtype=float)
                relative_data = config_data / reference_data
                job_row.append(np.average(config_data))
                job_row.append(np.std(config_data))
                job_row.append(np.average(relative_data))
                job_row.append(np.std(relative_data))
            table.add_row(job_row)

        with open(self.data_file, "w") as f:
            # Print the table rows sorted by the relative magnitude of the first method (best)
            # compared to the last one (worst)
            print >>f, table.get_string(sortby="Package", sort_key=lambda row: row[1+3], reversesort=True)

    def plot_graphs(self):
        plot = GnuplotScript(r"""
        set boxwidth 1.0 relative
        set style data histograms
        set style histogram errorbars

        set xlabel "Package"
        set xtics border out nomirror rotate by -15 offset -1, 0 scale 0

        set ylabel "Path Ratio (P / P_{Baseline})"
        set logscale y
        set yrange [0.1:*]
        set grid ytics

        set arrow 1 from graph 0, first 1 to graph 1, first 1 nohead ls 2

        set label "%(language)s" at graph 0, graph 1 left front offset 1, -1 font "Helvetica-Bold,14"

        set key top right

        plot "%(datafile)s" using 4:5:xticlabels(1) fs solid 0.8 lt 1 title columnhead(2), \
                         "" using 8:9               fs solid 0.4 lt 1 title columnhead(6), \
                         "" using 12:13             fs solid 0.2 lt 1 title columnhead(10), \
                         "" using 16:17             fs solid 0.0 lt 1 title columnhead(14)
        """)
        plot.plot(self.plot_file, datafile=self.data_file,
                  language=self.exp_config["breakdown"][self.language]["title"])


class BreakdownCoverageEffectiveness(Analysis):
    def __init__(self, exp_config, language):
        super(BreakdownCoverageEffectiveness, self).__init__(exp_config)
        self.language = language
        self.data_file = os.path.join(self.DATA_ROOT, "bkdown-stmtcov-%s.txt" % self.language)
        self.plot_file = os.path.join(self.PLOTS_ROOT, "bkdown-stmtcov-%s.eps" % self.language)

    def compute_data(self):
        breakdown_data = self.exp_config["breakdown"]

        header = ["Package", "Total"]
        for config in breakdown_data["config"]:
            header.append('"%s"' % config["label"])
            header.append('"%s Stdev"' % config["label"])
        table = prettytable.PrettyTable(header)
        table.set_style(prettytable.PLAIN_COLUMNS)

        for job in breakdown_data[self.language]["jobs"]:
            job_row = [job["name"]]
            src_filter = SourceFilter(job["coverage"].split())
            total_statements = None
            for config in breakdown_data["config"]:
                experiments = [Experiment(os.path.join(self.EXPERIMENT_ROOT, exp_dir,
                                                       config["strat-stmt"],
                                                       job["name"]))
                               for exp_dir in breakdown_data[self.language]["expdir"][config["expdir"]]]
                config_data = np.array([exp.countCoveredStatements(src_filter) for exp in experiments], dtype=float)
                job_row.append(np.average(config_data))
                job_row.append(np.std(config_data))
                total_statements = total_statements or experiments[0].countTotalStatements(src_filter)
            job_row.insert(1, total_statements)
            table.add_row(job_row)

        with open(self.data_file, "w") as f:
            # Sort by the coverage of the first method
            print >>f, table.get_string(sortby="Package", sort_key=lambda row: float(row[3])/row[2], reversesort=True)

    def plot_graphs(self):
        plot = GnuplotScript(r"""
        set boxwidth 1.0 relative
        set style data histograms
        set style histogram errorbars

        set xlabel "Package"
        set xtics border out nomirror rotate by -15 offset -1, 0 scale 0

        set ylabel "Line Coverage [%%]"
        set yrange [0:100]
        set grid ytics

        set label "%(language)s" at graph 0, graph 1 left front offset 1, -1 font "Helvetica-Bold,14"

        plot "%(datafile)s" using (100.0*$3/$2):(100.0*$4/$2):xticlabels(1) fs solid 0.8 lt 1 title columnhead(3), \
                         "" using (100.0*$5/$2):(100.0*$6/$2)               fs solid 0.4 lt 1 title columnhead(5), \
                         "" using (100.0*$7/$2):(100.0*$8/$2)               fs solid 0.2 lt 1 title columnhead(7), \
                         "" using (100.0*$9/$2):(100.0*$10/$2)              fs solid 0.0 lt 1 title columnhead(9)
        """)
        plot.plot(self.plot_file, datafile=self.data_file,
                  language=self.exp_config["breakdown"][self.language]["title"])


class BreakdownPathRatio(Analysis):
    START_MINUTES = 0
    END_MINUTES = 30

    def __init__(self, exp_config, language):
        super(BreakdownPathRatio, self).__init__(exp_config)
        self.language = language
        self.data_file = os.path.join(self.DATA_ROOT, "bkdown-progress-%s.txt" % self.language)
        self.plot_hlfrac_file = os.path.join(self.PLOTS_ROOT, "bkdown-prog-hlfrac-%s.eps" % self.language)
        self.plot_llfrac_file = os.path.join(self.PLOTS_ROOT, "bkdown-prog-llfrac-%s.eps" % self.language)

    def compute_data(self):
        breakdown_data = self.exp_config["breakdown"]

        table_concat = []
        for config in breakdown_data["config"]:
            table = prettytable.PrettyTable(["Time", "TotalHLFracAVG", "TotalHLFracSTD", "LLFracAVG", "LLFracSTD"])
            table.set_style(prettytable.PLAIN_COLUMNS)
            experiments = {}
            for job in breakdown_data[self.language]["jobs"]:
                experiments[job["name"]] = [Experiment(os.path.join(self.EXPERIMENT_ROOT, exp_dir,
                                                                    config["strat-path"],
                                                                    job["name"]))
                                            for exp_dir in breakdown_data[self.language]["expdir"][config["expdir"]]]
            for minute in range(self.START_MINUTES, self.END_MINUTES+1, 5):
                time_stamp = minute * 60 * 1000000
                hlfrac_data = np.array(
                    [[float(exp.high_level_tests.countSince(time_stamp))/len(exp.high_level_tests)
                      for exp in exp_list] for exp_list in experiments.itervalues()])
                llfrac_data = np.array(
                    [[float(exp.high_level_tests.countSince(time_stamp))/(exp.low_level_tests.countSince(time_stamp) or 1)
                      for exp in exp_list] for exp_list in experiments.itervalues()])

                table.add_row([minute,
                               np.average(np.average(hlfrac_data, axis=1)),
                               np.std(np.average(hlfrac_data, axis=1)),
                               np.average(np.average(llfrac_data, axis=1)),
                               np.std(np.average(llfrac_data, axis=1))])
            table_concat.append(table.get_string())

        with open(self.data_file, "w") as f:
            print >>f, "\n\n\n".join(table_concat)

    def _plot_hl_fraction(self):
        plot = GnuplotScript(r"""
        set xlabel "Time [minutes]"
        set xrange [0:30]

        set ylabel "Fraction of Total Paths [%%]"
        set yrange [0:100]

        set grid xtics ytics

        set key right bottom

        set label "%(language)s" at graph 0, graph 1 left front offset 1, -1 font "Helvetica-Bold,14"

        plot "%(datafile)s" index 0 using 1:($2*100.0):($3*100.0) with yerrorlines lt 1 pt 5 ps 0.9 title "%(config1)s", \
                         "" index 1 using 1:($2*100.0):($3*100.0) with yerrorlines lt 2 pt 6 ps 0.9 title "%(config2)s", \
                         "" index 2 using 1:($2*100.0):($3*100.0) with yerrorlines lt 2 pt 8 ps 0.9 title "%(config3)s", \
                         "" index 3 using 1:($2*100.0):($3*100.0) with yerrorlines lt 2 pt 10 ps 0.9 title "%(config4)s"
        """)
        cupa_configs = self.exp_config["breakdown"]["config"]
        plot.plot(self.plot_hlfrac_file, datafile=self.data_file,
                  language=self.exp_config["breakdown"][self.language]["title"],
                  config1=cupa_configs[0]["label"],
                  config2=cupa_configs[1]["label"],
                  config3=cupa_configs[2]["label"],
                  config4=cupa_configs[3]["label"])

    def _plot_ll_fraction(self):
        plot = GnuplotScript(r"""
        set xlabel "Time [minutes]"
        set xrange [0:30]

        set ylabel "Low-level/High-level Path Ratio [%%]"
        set yrange [0:70]

        set grid xtics ytics

        set key top right

        set label "%(language)s" at graph 0, graph 1 left front offset 1, -1 font "Helvetica-Bold,14"

        plot "%(datafile)s" index 0 using 1:($4*100.0):($5*100.0) with yerrorlines lt 1 pt 5 ps 0.9 title "%(config1)s", \
                         "" index 1 using 1:($4*100.0):($5*100.0) with yerrorlines lt 2 pt 6 ps 0.9 title "%(config2)s", \
                         "" index 2 using 1:($4*100.0):($5*100.0) with yerrorlines lt 2 pt 8 ps 0.9 title "%(config3)s", \
                         "" index 3 using 1:($4*100.0):($5*100.0) with yerrorlines lt 2 pt 10 ps 0.9 title "%(config4)s"
        """)
        cupa_configs = self.exp_config["breakdown"]["config"]
        plot.plot(self.plot_llfrac_file, datafile=self.data_file,
                  language=self.exp_config["breakdown"][self.language]["title"],
                  config1=cupa_configs[0]["label"],
                  config2=cupa_configs[1]["label"],
                  config3=cupa_configs[2]["label"],
                  config4=cupa_configs[3]["label"])

    def plot_graphs(self):
        self._plot_hl_fraction()
        self._plot_ll_fraction()


class OptEffectHLCount(Analysis):
    # TODO: Makes sense to split in two classes
    def __init__(self, exp_config, language):
        super(OptEffectHLCount, self).__init__(exp_config)
        self.language = language

        self.data_bar_file = os.path.join(self.DATA_ROOT, "optimizations-bars-%s.txt" % self.language)
        self.data_lines_file = os.path.join(self.DATA_ROOT, "optimizations-lines-%s.txt" % self.language)
        self.plot_bar_file = os.path.join(self.PLOTS_ROOT, "optimizations-bars-%s.eps" % self.language)
        self.plot_lines_file = os.path.join(self.PLOTS_ROOT, "optimizations-lines-%s.eps" % self.language)

    def compute_data(self):
        optimization_data = self.exp_config["optimizations"][self.language]

        lines_data = prettytable.PrettyTable()
        lines_data.set_style(prettytable.PLAIN_COLUMNS)
        lines_data.add_column("Package", ['"%s"' % opt["label"] for opt in optimization_data["opt"]])

        bar_header = ["Package"]
        for opt in optimization_data["opt"]:
            bar_header.append('"%s"' % opt["label-full"])
            bar_header.append('"%s Stdev"' % opt["label-full"])
        bar_data = prettytable.PrettyTable(bar_header)
        bar_data.set_style(prettytable.PLAIN_COLUMNS)

        for job_name in sorted(optimization_data["jobs"]):
            path_counts = []
            stddevs = []
            for optimization in optimization_data["opt"]:
                pc_list = []
                for expdir in optimization["expdir"]:
                    experiment = Experiment(os.path.join(self.EXPERIMENT_ROOT, expdir, optimization_data["config"],
                                            job_name))
                    pc_list.append(len(experiment.high_level_tests))
                pc_list = np.array(pc_list, dtype=float)
                path_counts.append(np.average(pc_list))
                stddevs.append(np.std(pc_list))

            # Normalize path counts
            stddevs = [stdev/path_counts[-1] for stdev in stddevs]
            path_counts = [pc/path_counts[-1] for pc in path_counts]

            lines_data.add_column(job_name, path_counts)
            lines_data.add_column("%s-stddev" % job_name, stddevs)
            bar_data.add_row([job_name] + [value
                                           for pair in zip(path_counts, stddevs)
                                           for value in pair])  # for pair in zip(...): for value in pair: yield value

        with open(self.data_lines_file, "w") as f:
            print >>f, lines_data
        with open(self.data_bar_file, "w") as f:
            print >>f, bar_data.get_string(sortby="Package", sort_key=lambda row: row[1+1])

    def _plot_bar(self):
        plot = GnuplotScript(r"""
        set style data histograms
        set style histogram errorbars
        set boxwidth 1.0 relative

        set key top right

        set xlabel "Package"
        set xtics border out nomirror offset -1, 0 rotate by -15 scale 0

        set ylabel "Path Ratio (P / P_{FullOpt}) [%%]"
        set yrange [0:250]

        set arrow 1 from graph 0, first 100 to graph 1, first 100 nohead ls 1
        set grid ytics

        plot "%(datafile)s" using (100*$2):(100*$3):xticlabels(1) fs solid 0.0 lt 1 title columnhead(2), \
                         "" using (100*$4):(100*$5)               fs solid 0.3 lt 1 title columnhead(4), \
                         "" using (100*$6):(100*$7)               fs solid 0.6 lt 1 title columnhead(6), \
                         "" using (100*$8):(100*$9)               fs solid 0.9 lt 1 title columnhead(8)
        """)

        plot.plot(self.plot_bar_file, datafile=self.data_bar_file)

    def _plot_lines(self):
        plot = GnuplotScript(r"""
        set style data yerrorlines

        set key top right

        unset xlabel #set xlabel "Optimizations"
        set xtics border in nomirror scale 0

        set ylabel "Path Ratio (P / P_{FullOpt}) [%%]"
        set yrange [0:250]

        set grid ytics

        plot for [i=1:6] "%(datafile)s" using 0:(100*column(2*i)):(100*column(2*i+1)):xtic(1) lt 1 title columnhead(2*i)
        """)

        plot.plot(self.plot_lines_file, width="3.4 in", height="1.6 in", font_size=12, datafile=self.data_lines_file)

    def plot_graphs(self):
        self._plot_bar()
        self._plot_lines()


class OptEffectHLRatio(Analysis):
    def __init__(self, exp_config, language):
        super(OptEffectHLRatio, self).__init__(exp_config)
        self.language = language

        self.data_file = os.path.join(self.DATA_ROOT, "optim-hlratio-%s.txt" % self.language)
        self.plot_file = os.path.join(self.PLOTS_ROOT, "optim-hlratio-%s.eps" % self.language)

    def compute_data(self):
        optimization_data = self.exp_config["optimizations"][self.language]

        table = prettytable.PrettyTable()
        table.set_style(prettytable.PLAIN_COLUMNS)
        table.add_column("Package", ['"%s"' % opt["label"] for opt in optimization_data["opt"]])

        for job_name in sorted(optimization_data["jobs"]):
            avg_column = []
            std_column = []
            for optimization in optimization_data["opt"]:
                hl_ratios = []
                for expdir in optimization["expdir"]:
                    experiment = Experiment(os.path.join(self.EXPERIMENT_ROOT, expdir,
                                                         optimization_data["config"], job_name))
                    hl_ratios.append(float(len(experiment.high_level_tests))/len(experiment.low_level_tests))
                hl_ratios = np.array(hl_ratios, dtype=float)
                avg_column.append(np.average(hl_ratios))
                std_column.append(np.std(hl_ratios))

            # Normalize
            std_column = [std/avg_column[-1] for std in std_column]
            avg_column = [avg/avg_column[-1] for avg in avg_column]

            table.add_column(job_name, avg_column)
            table.add_column("%s-stddev" % job_name, std_column)

        with open(self.data_file, "w") as f:
            print >>f, table

    def plot_graphs(self):
        plot = GnuplotScript(r"""
        set style data linespoints

        set key bottom right

        set xlabel "Optimizations"
        set xtics border out nomirror rotate by -15 offset -1, 0 scale 0

        set ylabel "Fraction of LL Paths [%%]"
        set yrange [0:*]

        set grid ytics

        plot for [i=1:6] "%(datafile)s" using 0:(100*column(2*i)):xtic(1) lt 1 title columnhead(2*i)
        """)

        plot.plot(self.plot_file, datafile=self.data_file)


class GnuplotTest(Analysis):
    def plot_graphs(self):
        plot = GnuplotScript(r"""
        test
        """)

        plot.plot(os.path.join(self.PLOTS_ROOT, "test.eps"))


def main():
    parser = argparse.ArgumentParser(description="Experimental data processing")
    parser.add_argument("exp_config", type=argparse.FileType("r"),
                        help="The experimental data configuration file")
    parser.add_argument("-g", "--only-graphs", action="store_true", default=False,
                        help="Only regenerate graphs")

    args = parser.parse_args()
    exp_config = yaml.load(args.exp_config)

    analyses = [
        NICEComparison(exp_config),
        NICEOptimizationImpact(exp_config),
        BreakdownPathEffectiveness(exp_config, "python"),
        BreakdownPathEffectiveness(exp_config, "lua"),
        BreakdownCoverageEffectiveness(exp_config, "python"),
        BreakdownCoverageEffectiveness(exp_config, "lua"),
        BreakdownPathRatio(exp_config, "python"),
        BreakdownPathRatio(exp_config, "lua"),
        OptEffectHLCount(exp_config, "python"),
        #OptEffectHLCount(exp_config, "lua"),
        #OptEffectHLRatio(exp_config, "python"),
        #OptEffectHLRatio(exp_config, "lua"),
        GnuplotTest(exp_config)
    ]

    for analysis in analyses:
        if not args.only_graphs:
            analysis.compute_data()
        analysis.plot_graphs()


if __name__ == "__main__":
    main()
